<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D å­”å¾‘ç¹å°„ (FFT)</title>
    <style>
        /* ç¹¼æ‰¿ä¸€è²«çš„å¯¦é©—å®¤é¢¨æ ¼ */
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background: #000; color: #eee; margin: 0; padding: 20px;
            display: flex; flex-direction: column; align-items: center;
        }
        .nav { width: 100%; margin-bottom: 20px; text-align: left; }
        .nav a { color: #00d4ff; text-decoration: none; font-size: 14px; }
        
        h2 { color: #00d4ff; margin-bottom: 5px; }
        p { color: #888; font-size: 12px; margin-bottom: 20px; }

        .container {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 20px;
            width: 100%; max-width: 800px;
        }

        /* æ§åˆ¶å€ */
        .controls {
            background: #1a1a1a; padding: 20px; border-radius: 12px; border: 1px solid #333;
            flex: 1; min-width: 250px;
        }
        .slider-group { margin-bottom: 20px; }
        .label { display: flex; justify-content: space-between; margin-bottom: 8px; color: #ccc; font-size: 14px; }
        .val { color: #00d4ff; font-family: monospace; }
        input[type=range] { width: 100%; accent-color: #00d4ff; cursor: pointer; }

        /* ç•«å¸ƒå€ */
        .visuals {
            display: flex; gap: 10px; align-items: center; justify-content: center;
            background: #111; padding: 20px; border-radius: 12px; border: 1px solid #333;
        }
        .canvas-box { text-align: center; }
        .canvas-title { font-size: 10px; color: #666; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 5px; display: block; }
        
        canvas { 
            border: 1px solid #444; background: #000; 
            width: 150px; height: 150px; /* é¡¯ç¤ºå¤§å° */
            image-rendering: pixelated; /* ä¿æŒåƒç´ æ„Ÿ */
            border-radius: 4px;
        }
        
        .arrow { font-size: 24px; color: #444; }

        .loading { color: #ffcc00; font-size: 12px; margin-top: 5px; min-height: 18px; text-align: center;}
    </style>
</head>
<body>

    <div class="nav"><a href="../index.html">â† è¿”å›å¯¦é©—å®¤å…¥å£</a></div>
    <h2>ğŸ”· å¹¾ä½•å­”å¾‘ç¹å°„æ¨¡æ“¬</h2>
    <p>ä½¿ç”¨ 2D FFT æ¼”ç®—æ³•è¨ˆç®—å¤«æœ—å’Œæ–ç¹å°„åœ–æ¨£</p>

    <div class="container">
        <div class="controls">
            <div class="slider-group">
                <div class="label">å½¢ç‹€é‚Šæ•¸ (n) <span id="val_n" class="val">3</span></div>
                <input type="range" id="inp_n" min="3" max="12" value="3">
            </div>
            <div class="slider-group">
                <div class="label">æ—‹è½‰è§’åº¦ (Â°) <span id="val_rot" class="val">0</span></div>
                <input type="range" id="inp_rot" min="0" max="360" value="0">
            </div>
            <div class="slider-group">
                <div class="label">å­”å¾‘å¤§å° <span id="val_size" class="val">10</span></div>
                <input type="range" id="inp_size" min="5" max="30" value="10">
            </div>
            <div id="status" class="loading"></div>
        </div>

        <div class="visuals">
            <div class="canvas-box">
                <span class="canvas-title">å­”å¾‘å½¢ç‹€ (Aperture)</span>
                <canvas id="canvasInput" width="128" height="128"></canvas>
            </div>
            <div class="arrow">âœ</div>
            <div class="canvas-box">
                <span class="canvas-title">ç¹å°„åœ–æ¨£ (Diffraction)</span>
                <canvas id="canvasOutput" width="128" height="128"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- 1. æ ¸å¿ƒæ•¸å­¸å·¥å…· (ä¿ç•™åŸé‚è¼¯) ---
        class Complex {
            constructor(re, im) { this.re = re; this.im = im; }
            add(other) { return new Complex(this.re + other.re, this.im + other.im); }
            sub(other) { return new Complex(this.re - other.re, this.im - other.im); }
            mul(other) {
                return new Complex(
                    this.re * other.re - this.im * other.im,
                    this.re * other.im + this.im * other.re
                );
            }
        }

        const fft = (amplitudes) => {
            const N = amplitudes.length;
            if (N <= 1) return amplitudes;
            const even = fft(amplitudes.filter((_, i) => i % 2 === 0));
            const odd = fft(amplitudes.filter((_, i) => i % 2 !== 0));
            const results = new Array(N);
            for (let k = 0; k < N / 2; k++) {
                const angle = -2 * Math.PI * k / N;
                const t = new Complex(Math.cos(angle), Math.sin(angle)).mul(odd[k]);
                results[k] = even[k].add(t);
                results[k + N / 2] = even[k].sub(t);
            }
            return results;
        };

        const fft2D = (input2D) => {
            const rows = input2D.length;
            const cols = input2D[0].length;
            let rowResult = [];
            for (let i = 0; i < rows; i++) rowResult.push(fft(input2D[i]));
            let transposed = Array(cols).fill(0).map(() => Array(rows).fill(0));
            for (let i = 0; i < rows; i++) for (let j = 0; j < cols; j++) transposed[j][i] = rowResult[i][j];
            let colResult = [];
            for (let i = 0; i < cols; i++) colResult.push(fft(transposed[i]));
            let final = Array(rows).fill(0).map(() => Array(cols).fill(0));
            for (let i = 0; i < cols; i++) for (let j = 0; j < rows; j++) final[j][i] = colResult[i][j];
            return final;
        };

        const fftShift = (data) => {
            const rows = data.length;
            const cols = data[0].length;
            const midR = Math.floor(rows / 2);
            const midC = Math.floor(cols / 2);
            const shifted = Array(rows).fill(0).map(() => Array(cols));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    shifted[(r + midR) % rows][(c + midC) % cols] = data[r][c];
                }
            }
            return shifted;
        };

        // --- 2. ä»‹é¢äº’å‹•é‚è¼¯ ---
        const SIM_SIZE = 128; // é‹ç®—è§£æåº¦ (128x128 é€Ÿåº¦å¿«)
        const cvsIn = document.getElementById('canvasInput');
        const cvsOut = document.getElementById('canvasOutput');
        const ctxIn = cvsIn.getContext('2d');
        const ctxOut = cvsOut.getContext('2d');

        const inpN = document.getElementById('inp_n');
        const inpRot = document.getElementById('inp_rot');
        const inpSize = document.getElementById('inp_size');
        const valN = document.getElementById('val_n');
        const valRot = document.getElementById('val_rot');
        const valSize = document.getElementById('val_size');
        const statusEl = document.getElementById('status');

        let isComputing = false;
        let pendingUpdate = false;

        // åˆå§‹åŒ–
        updateSimulation();

        // äº‹ä»¶ç›£è½
        [inpN, inpRot, inpSize].forEach(el => {
            el.addEventListener('input', () => {
                // UI æ•¸å€¼å³æ™‚æ›´æ–°
                valN.innerText = inpN.value;
                valRot.innerText = inpRot.value;
                valSize.innerText = inpSize.value;
                
                // é˜²æŠ–å‹•è™•ç† (Debounce logic)
                if (!isComputing) {
                    requestAnimationFrame(updateSimulation);
                } else {
                    pendingUpdate = true;
                }
            });
        });

        function updateSimulation() {
            isComputing = true;
            statusEl.innerText = "é‹ç®—ä¸­...";
            
            // 1. ç¹ªè£½å­”å¾‘ (Draw Aperture)
            const n = parseInt(inpN.value);
            const rotation = parseInt(inpRot.value);
            const size = parseInt(inpSize.value);

            ctxIn.fillStyle = '#000000';
            ctxIn.fillRect(0, 0, SIM_SIZE, SIM_SIZE);
            ctxIn.fillStyle = '#FFFFFF';
            
            ctxIn.beginPath();
            const centerX = SIM_SIZE / 2;
            const centerY = SIM_SIZE / 2;
            const r = size * (SIM_SIZE / 100) * 2; // èª¿æ•´å¤§å°æ¯”ä¾‹
            
            for (let i = 0; i <= n; i++) {
                const theta = (i * 2 * Math.PI / n) - (Math.PI / 2) + (rotation * Math.PI / 180);
                const x = centerX + r * Math.cos(theta);
                const y = centerY + r * Math.sin(theta);
                if (i === 0) ctxIn.moveTo(x, y); else ctxIn.lineTo(x, y);
            }
            ctxIn.closePath();
            ctxIn.fill();

            // 2. åŸ·è¡Œ FFT (ç‚ºäº†ä¸å¡ä½ UIï¼Œä½¿ç”¨ setTimeout æ”¾åˆ°ä¸‹ä¸€å€‹ Tick)
            setTimeout(() => {
                computeFFT();
            }, 10);
        }

        function computeFFT() {
            // è®€å–å­”å¾‘åœ–åƒ
            const imgData = ctxIn.getImageData(0, 0, SIM_SIZE, SIM_SIZE);
            const data = imgData.data;
            let input2D = [];
            
            // è½‰æ›ç‚ºè¤‡æ•¸çŸ©é™£
            for (let y = 0; y < SIM_SIZE; y++) {
                let row = [];
                for (let x = 0; x < SIM_SIZE; x++) {
                    // å–ç´…è‰²é€šé“ä½œç‚ºäº®åº¦
                    row.push(new Complex(data[(y * SIM_SIZE + x) * 4], 0));
                }
                input2D.push(row);
            }

            // FFT é‹ç®—
            const spectrum = fft2D(input2D);
            const shifted = fftShift(spectrum);

            // è¨ˆç®—å¼·åº¦ä¸¦å°‹æ‰¾æœ€å¤§å€¼ (ç”¨æ–¼æ­£è¦åŒ–)
            let maxVal = 0;
            let intensities = [];
            for (let y = 0; y < SIM_SIZE; y++) {
                let rowInt = [];
                for (let x = 0; x < SIM_SIZE; x++) {
                    const c = shifted[y][x];
                    // å°æ•¸ç¸®æ”¾ Log scale (æ¨¡æ“¬äººçœ¼å°äº®åº¦çš„æ„ŸçŸ¥)
                    const val = Math.log(1 + Math.sqrt(c.re * c.re + c.im * c.im));
                    if (val > maxVal) maxVal = val;
                    rowInt.push(val);
                }
                intensities.push(rowInt);
            }

            // ç¹ªè£½çµæœ
            const outImgData = ctxOut.createImageData(SIM_SIZE, SIM_SIZE);
            for (let y = 0; y < SIM_SIZE; y++) {
                for (let x = 0; x < SIM_SIZE; x++) {
                    const idx = (y * SIM_SIZE + x) * 4;
                    const normalized = intensities[y][x] / (maxVal || 1);
                    
                    // Inferno Colormap (ä»¿ç…§åŸç¨‹å¼çš„é…è‰²)
                    // R: å¿«é€Ÿä¸Šå‡
                    outImgData.data[idx] = Math.min(255, normalized * 255 * 2.5); 
                    // G: ä¸­æ®µä¸Šå‡ (å¹³æ–¹é—œä¿‚)
                    outImgData.data[idx + 1] = Math.min(255, Math.pow(normalized, 2) * 255 * 2);
                    // B: æ…¢é€Ÿä¸Šå‡ (æ ¹è™Ÿé—œä¿‚ï¼Œå¢åŠ æš—éƒ¨ç´°ç¯€)
                    outImgData.data[idx + 2] = Math.min(255, Math.pow(normalized, 0.5) * 255);
                    outImgData.data[idx + 3] = 255; // Alpha
                }
            }
            ctxOut.putImageData(outImgData, 0, 0);

            // ç‹€æ…‹è§£é™¤
            isComputing = false;
            statusEl.innerText = "";
            
            // å¦‚æœåœ¨é‹ç®—æœŸé–“æœ‰æ–°çš„è¼¸å…¥ï¼Œé‡æ–°è§¸ç™¼
            if (pendingUpdate) {
                pendingUpdate = false;
                updateSimulation();
            }
        }
    </script>
</body>
</html>
